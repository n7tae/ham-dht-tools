/*
 *   Copyright (c) 2024 by Thomas A. Early N7TAE
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <nlohmann/json.hpp>
#include <curl/curl.h>
#include <opendht.h>
#include <iostream>
#include <sstream>
#include <string>
#include <mutex>
#include <condition_variable>

#include "dht-values.h"
#include "dht-helpers.h"

static const std::string Version("1.1.0");
std::string hostname("xrf757.openquad.net");
static bool got_data;
static bool running;
static std::condition_variable cv;
static std::mutex mtx;
static char section = 'a';
static bool use_local = false;
static dht::Where w;
static SMrefdConfig1  mrefdConfig;
static SUrfdConfig1   urfdConfig;


// callback function writes data to a std::ostream
static size_t data_write(void  *buf, size_t size, size_t nmemb, void *userp)
{
	if(userp)
	{
		std::ostream &os = *static_cast<std::ostream *>(userp);
		std::streamsize len = size * nmemb;
		if(os.write(static_cast<char*>(buf), len))
			return len;
	}

	return 0;
}

/**
 * timeout is in seconds
 **/
static CURLcode curl_read(const std::string& url, std::ostream& os, long timeout = 30)
{
	CURLcode code(CURLE_FAILED_INIT);
	CURL* curl = curl_easy_init();

	if(curl)
	{
		if(CURLE_OK == (code = curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, &data_write))
		&& CURLE_OK == (code = curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L))
		&& CURLE_OK == (code = curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L))
		&& CURLE_OK == (code = curl_easy_setopt(curl, CURLOPT_FILE, &os))
		&& CURLE_OK == (code = curl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout))
		&& CURLE_OK == (code = curl_easy_setopt(curl, CURLOPT_URL, url.c_str())))
		{
			code = curl_easy_perform(curl);
		}
		curl_easy_cleanup(curl);
	}
	return code;
}

static void ReadM17Json(const std::string &url, std::stringstream &ss)
{
	curl_global_init(CURL_GLOBAL_ALL);

	if(CURLE_OK == curl_read(url, ss)) {
		std::cout << "# Copied " << url << std::endl;
	} else {
		std::cout << "# ERROR: Could not copy " << url << std::endl;
	}

	curl_global_cleanup();
}

std::string comname;

using json = nlohmann::json;
#define GET_STRING(a) ((a).is_string() ? a : "null")

static void Usage(std::ostream &ostr)
{
	ostr << std::endl << "Usage: " << comname << " [Option]" << std::endl << std::endl;
	ostr << "There are three mutually exclusive options:" << std::endl << std::endl;
	ostr << "-b hostname" << std::endl;
	ostr << "   Where 'hostname' is any running node on the Ham-DHT network" << std::endl;
	ostr << "   If not specified, " << hostname << " will be used." << std::endl;
	ostr << "-v | --version" << std::endl;
	ostr << "   Will print the version and exit." << std::endl;
	ostr << "-h | --help" << std::endl;
	ostr << "   Will print this usage message and exit." << std::endl;
}


int main (int argc, char *argv[])
{
	comname.assign(argv[0])
;	if (2 == argc)
	{
		const std::string arg(argv[1]);
		if (0 == arg.compare("-v") or 0 == arg.compare("--version"))
		{
			std::cout << "Version #" << Version << std::endl;
			return EXIT_SUCCESS;
		}
		else if (0 == arg.compare("-h") || 0 == arg.compare("--help"))
		{
			Usage(std::cout);
			return EXIT_SUCCESS;
		}
		Usage(std::cerr);
		return EXIT_FAILURE;
	}
	else if (3 == argc)
	{
		const std::string arg(argv[1]);
		if (0 == arg.compare("-b"))
			hostname.assign(argv[2]);
		else
		{
			Usage(std::cerr);
			return EXIT_FAILURE;
		}
	}
	else if (3 < argc)
	{
		Usage(std::cerr);
		return EXIT_FAILURE;
	}

	// boot up the Ham-DTH
	std::string name("GetM17Hosts");
	name += std::to_string(getpid());
	dht::DhtRunner node;
	node.run(17171, dht::crypto::generateIdentity(name), true, 59973);
	node.bootstrap(hostname, "17171");

	// print the preamble
	std::cout << "# M17 Hosts file generated by " << comname << " V#" << Version << std::endl;
	std::cout << "# Copyright (C) 2024-2025 by Thomas A. Early, N7TAE." << std::endl;
	std::cout << "# See the LICENSE file in https://github.com/n7tae/dht-ham-tools." << std::endl;
	auto t = std::time(nullptr);
	auto tm = *std::gmtime(&t);
	std::cout << "# Created on " << std::put_time(&tm, "%Y-%m-%d at %H:%M GMT") << std::endl;

	// downlaod and parse the mrefd and urf json file
	std::stringstream ss;
	ReadM17Json("https://dvref.com/mrefd/reflectors/", ss);
	json mref = json::parse(ss.str());
	ss.str(std::string());

	ReadM17Json("https://dvref.com/urfd/reflectors/", ss);
	json urf = json::parse(ss.str());
	ss.str(std::string());

	std::cout << "# A null 'IPv4Address' or 'IPv6Address' means it's not configured." << std::endl;
	std::cout << "# A null 'Modules' means it can't be determined." << std::endl;
	std::cout << '#' << std::endl;
	std::cout << "# 'SpecialModules' for M17 reflectors will pass encrypted voice data." << std::endl;
	std::cout << "# 'SpecialModules' for URF reflectors are fully transcoded." << std::endl;
	std::cout << '#' << std::endl;
	std::cout << "# A null 'SpecialModules' value can mean either:" << std::endl;
	std::cout << "#   1) If 'Modules' is null, it can't be determined, or," << std::endl;
	std::cout << "#   2) if 'Modules' is NOT null, there are no special modules." << std::endl;
	std::cout << '#' << std::endl;
	std::cout << std::left << std::setw(8)  << "#Refl"
			  << std::left << std::setw(16) << "IPv4Address"
			  << std::left << std::setw(40) << "IPv6Address"
			  << std::left << std::setw(27) << "Modules"
			  << std::left << std::setw(27) << "SpecialModules"
			  << std::left << std::setw(7)  << "Port"
			  << std::left << std::setw(11) << "Source" 
			  << std::left <<                  "Dashboard-URL" << std::endl;

	w.id(toUType(EMrefdValueID::Config));
	// iterate through reflectors array
	for (auto &ref : mref["reflectors"])
	{
		running = true;
		got_data = false;
		std::string refcs("M17-");
		refcs.append(ref["designator"].get<std::string>());
		std::string ipv4(GET_STRING(ref["ipv4"]));
		std::string ipv6(GET_STRING(ref["ipv6"]));

		// skip the bullsh*t
		if (0 == ipv4.compare("127.0.0.1") || 0 == ipv4.compare("0.0.0.0") || 0 == ipv4.compare("::1") || 0 == ipv4.compare("::"))
			continue;

		std::string mods("null");
		std::string smods("null");
		uint16_t port = ref["port"];
		std::string url(ref["url"]);
		auto keyhash = dht::InfoHash::get(refcs);
		mrefdConfig.timestamp = 0;
		node.get(
			keyhash,
			[](const std::shared_ptr<dht::Value> &v) {
				if (v->checkSignature())
				{
					switch (v->id)
					{
						case toUType(EMrefdValueID::Config):
							if (0 == v->user_type.compare(MREFD_CONFIG_1))
							{
								got_data = true;
								auto rdat = dht::Value::unpack<SMrefdConfig1>(*v);
								if (rdat.timestamp > mrefdConfig.timestamp)
									mrefdConfig = dht::Value::unpack<SMrefdConfig1>(*v);
							}
							break;
					}
				}
				else
				{
					std::cerr << "Value signature failed!" << std::endl;
				}
				return true;
			},
			[](bool success) {
				if (! success)
					std::cout << "get() unsuccessful!" << std::endl;
				std::unique_lock<std::mutex> lck(mtx);
				running = false;
				cv.notify_all();
			},
			{},	// empty filter
			w
		);

		// wait for node.get()
		std::unique_lock<std::mutex> lck(mtx);
		while (running)
		{
			cv.wait(lck);
		}

		std::string src("dvref.com");
		if (got_data)
		{
			if (mrefdConfig.ipv4addr.size())
				ipv4.assign(mrefdConfig.ipv4addr);
			if (mrefdConfig.ipv6addr.size())
				ipv6.assign(mrefdConfig.ipv6addr);
			if (mrefdConfig.modules.size())
				mods.assign(mrefdConfig.modules);
			if (mrefdConfig.encryptedmods.size())
				smods.assign(mrefdConfig.encryptedmods);
			if (mrefdConfig.url.size())
				url.assign(mrefdConfig.url);
			port = mrefdConfig.port;
			src.assign("Ham-DHT");
		}
		std::cout << std::left << std::setw(8)  << refcs
		          << std::left << std::setw(16) << ipv4
				  << std::left << std::setw(40) << ipv6
				  << std::left << std::setw(27) << mods
				  << std::left << std::setw(27) << smods
				  << std::left << std::setw(7)  << port
				  << std::left << std::setw(11) << src
				  << std::left <<                  url << std::endl;
	}

	// now for the URF reflectors
	w.id(toUType(EUrfdValueID::Config));
	// iterate through reflectors array
	for (auto &ref : urf["reflectors"])
	{
		running = true;
		got_data = false;
		std::string refcs("URF");
		refcs.append(ref["designator"].get<std::string>());
		std::string ipv4(GET_STRING(ref["ipv4"]));
		std::string ipv6(GET_STRING(ref["ipv6"]));

		// skip the bulls*it
		if (0 == ipv4.compare("127.0.0.1") || 0 == ipv4.compare("0.0.0.0") || 0 == ipv6.compare("::1") || 0 == ipv6.compare("::"))
			continue;

		// fish out the modules and transcoded modules
		std::string mods, smods;
		uint16_t port = 17000u;
		if (ref["modules"].size())
		{
			for (auto &m : ref["modules"])
			{
				if (m["module"].is_string())
				{
					const auto module(m["module"].get<std::string>());
					mods.append(module);
					if (m["mode"].is_string())
					{
						const auto mode(m["mode"].get<std::string>());
						if (0 == mode.compare("All"))
						{
							if (m["transcode"].is_boolean())
							{
								if (m["transcode"].get<bool>())
									smods.append(module);
							}
						}
						else if (0 == mode.compare("M17"))
						{
							if (m["port"].is_number_unsigned())
								port = m["port"].get<uint16_t>();
						}
					}
				}
			}
			if (0 == mods.size())
				mods.assign("null");
			if (0 == smods.size())
				smods.assign("null");
		}
		else
		{
			// no modules specified
			mods.assign("null");
			smods.assign("null");
		}
		std::string url(ref["url"]);
		auto keyhash = dht::InfoHash::get(refcs);
		urfdConfig.timestamp = 0;
		node.get(
			keyhash,
			[](const std::shared_ptr<dht::Value> &v) {
				if (v->checkSignature())
				{
					switch (v->id)
					{
					case toUType(EUrfdValueID::Config):
						if (0 == v->user_type.compare(URFD_CONFIG_1))
						{
							got_data = true;
							auto rdat = dht::Value::unpack<SUrfdConfig1>(*v);
							if (rdat.timestamp > urfdConfig.timestamp)
								urfdConfig = dht::Value::unpack<SUrfdConfig1>(*v);
						}
					}
				}
				else
				{
					std::cerr << "Value signature failed!" << std::endl;
				}
				return true;
			},
			[](bool success) {
				if (! success)
					std::cout << "get() unsuccessful!" << std::endl;
				std::unique_lock<std::mutex> lck(mtx);
				running = false;
				cv.notify_all();
			},
			{},	// empty filter
			w
		);

		// wait for node.get()
		std::unique_lock<std::mutex> lck(mtx);
		while (running)
		{
			cv.wait(lck);
		}

		std::string src("dvref.com");
		if (got_data)
		{
			if (urfdConfig.ipv4addr.size())
				ipv4.assign(urfdConfig.ipv4addr);
			if (urfdConfig.ipv6addr.size())
				ipv6.assign(urfdConfig.ipv6addr);
			if (urfdConfig.modules.size())
				mods.assign(urfdConfig.modules);
			if (urfdConfig.transcodedmods.size())
				smods.assign(urfdConfig.transcodedmods);
			port = urfdConfig.port[toUType(EUrfdPorts::m17)];
			src.assign("Ham-DHT");
			if (urfdConfig.url.size())
				url.assign(urfdConfig.url);
		}
		std::cout << std::left << std::setw(8)  << refcs
		          << std::left << std::setw(16) << ipv4
				  << std::left << std::setw(40) << ipv6
				  << std::left << std::setw(27) << mods
				  << std::left << std::setw(27) << smods
				  << std::left << std::setw(7)  << port
				  << std::left << std::setw(11) << src
				  <<                               url << std::endl;
	}

	node.join(); // disconnect from the Ham-DHT

	return EXIT_SUCCESS;
}
